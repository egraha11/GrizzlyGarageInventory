/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package group4.grizzlygarageinventory;

/**
 *
 * @author evan
 */

//class to find items by item name 
public class HashTable {
    
    private Item[] table;
    private int spacesInStructure;
    private int nodesInStructure = 0;
    private Item nodeIsDeleted;
    private final double maxPercentage = .75;
    

    public HashTable(int startingLength){
        
        if(startingLength < 20){
            startingLength = 50;
        }
        spacesInStructure = fourKPlus3(startingLength + 1);//start with 1000 nodes in structure 
        table = new Item[spacesInStructure];
        nodeIsDeleted = new Item("", 0, 0, "", "", 0);
        
    }
    
    //come up with a four k plus 3 prime number to size the array and minimize collisions
    public int fourKPlus3(int numberOfNodes){
        
       int startingPrime = (int)(numberOfNodes * 1.33);
       
       
       boolean primeNumber = false;
       boolean fourKPlus3 = false;
        
       if(startingPrime % 2 == 0){
           startingPrime++;
       }
       
       while(fourKPlus3 == false){
           int testedPrime = (int)(Math.sqrt(startingPrime) + .5);
           
           int i;
           
           while(primeNumber == false){
                for (i = testedPrime; i > 1; i--){
                    if(startingPrime % i == 0){
                        break;
                    }
                }      
                if(i != 1){
                    startingPrime = startingPrime + 2;
                }
                else{
                    primeNumber = true;
                }
           }
           if(((startingPrime) - 3) % 4 == 0){
               fourKPlus3 = true;
           }
           else{
               primeNumber = false;
               startingPrime = startingPrime + 2;
           } 
       }
       return startingPrime;  
    }
    
    //insert a new item into the hash table
    public void insert(Item newItem){

        if((double)(nodesInStructure / spacesInStructure) >= maxPercentage){
            Item[] temp = table;
            
            spacesInStructure = fourKPlus3(nodesInStructure + 1000);
            Item[] newArray = new Item[spacesInStructure];
            
            table = newArray;
            
            for(int i = 0; i < temp.length; i++){
                if(temp[i] != null || temp[i] != nodeIsDeleted){
                    insert(temp[i]);
                }
            }
            //resize and reinitialize a new array
        }
        
        boolean hit = false;
        int preKey = preProcess(newItem.getName());
        int offset = preKey / spacesInStructure;
  
        if(offset % spacesInStructure == 0){
            offset = 9967;//4k+3 prime number in case the offset generated by the preprocessed key results in infinite collisons
        }
           
        int key = preKey % spacesInStructure;
        
        while(hit == false){
            if(table[key] == null || table[key] == nodeIsDeleted){
                if(table[key] == null){
                    nodesInStructure++;
                }
            table[key] = newItem;
            //System.out.println(table[key].toString());
            hit = true;
            }
            else{
                key = (key + offset) % spacesInStructure;
            }   
        }
    }
    
    //string to an int 
    public int preProcess(String newItemString){
        
        String processString = newItemString.replaceAll("\\s", "");
        String lowerCaseString = processString.toLowerCase();
        
        int preProcessedKey = 0;
        int characterCount = 0;
        int group = 0;
        
        char[] c = lowerCaseString.toCharArray();
        
        while(characterCount < c.length){
            group = group << 8;
            group =+ c[characterCount];
            
            characterCount++;
            
            if(characterCount % 4 == 0 || characterCount == c.length - 1){
                preProcessedKey += group;
                group = 0;
            }
        }
        while(preProcessedKey < spacesInStructure){
            preProcessedKey = preProcessedKey * 2;
        }

        return preProcessedKey; //make sure the preprocessing key is more that the number of spaces in structure
    }
    
    //delete an item from the hash table
    public void delete(Item itemToBeDeleted){
        
        int preKey = preProcess(itemToBeDeleted.getName());
        int offset = preKey / spacesInStructure;
        
        if(offset % spacesInStructure == 0){
            offset = 9967;//4k+3 prime number in case the offset generated by the preprocessed key results in infinite collisons
        }
           
        int key = preKey % spacesInStructure;
        
        while(!(table[key].toString().equals(itemToBeDeleted.toString()))){
            key = (key + offset) % spacesInStructure;
        }
        table[key] = nodeIsDeleted;
    }
    
    //fetch an item form the hash table
    public Item[] fetch(Item itemToFind){
        
        LinkedList itemList = new LinkedList();//keep track of items to be returned so as to not use to much memory making a large array with null pointers
        int counter = 0;
        
        int preKey = preProcess(itemToFind.getName());
        int offset = preKey / spacesInStructure;
        
        if(offset % spacesInStructure == 0){
            offset = 9967;//4k+3 prime number in case the offset generated by the preprocessed key results in infinite collisons
        }
           
        int key = preKey % spacesInStructure;
        
        while(table[key] != null){//continue to search for all items matching the string
            if(table[key] != nodeIsDeleted && itemToFind.getName().equalsIgnoreCase(table[key].getName())){
                
                if(itemToFind.matchItem(table[key]) == true){
                    System.out.println(table[key].toString());
                    itemList.insert(table[key]);
                }
            }

            key = (key + offset) % spacesInStructure;;
        }
        
        Item[] returnArray = itemList.returnAll();
        
        return returnArray;
    }
    
    //return all items in hash table
    public void returnAll(){
        for(int i = 0; i < table.length; i++){
            if(table[i] != null){
                System.out.println(table[i].toString());
            }
        }
    }
    
    //update an existing item in the hash table 
    public void update(Item oldItem, Item newItem){
        delete(oldItem);
        insert(newItem);
    }
}
